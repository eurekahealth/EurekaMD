import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed

from fireworks.client import Fireworks

from openai import OpenAI
import pandas as pd
from tqdm import tqdm

from prompts import answer_via_ensemble, create_examples


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("--similar-questions-file-location", type=str, default="data/generated/similar_training_questions_to_test.csv", help="The location of the file mapping training questions to similar test questions.")
    parser.add_argument("--train-data-file-location", type=str, default="data/questions/medqa_4_options_train.jsonl", help="The location of the test set to evaluate.")
    parser.add_argument("--test-data-file-location", type=str, default="data/questions/medqa_4_options_test.jsonl", help="The location of the test set to evaluate.")
    parser.add_argument("--gpt-cot-file-location", type=str, default="data/generated/gpt-4o_training_cots.csv", help="The location of the training chain of thoughts generated by gpt.")
    parser.add_argument("--llama-cot-file-location", type=str, default="data/generated/llama_training_cots.csv", help="The location of the training chain of thoughts generated by llama.")
    parser.add_argument("--router-preferences-file-location", type=str, default="data/generated/router_preferences.csv", help="The location of the router preferences file.")
    parser.add_argument("--temp", type=float, default=1.0, help="The temperature to use.")
    parser.add_argument("--num-examples", type=int, default=5, help="The number of examples to inject for in-context learning.")
    parser.add_argument("--num-shuffles", type=int, default=5, help="The number of shuffles to perform as part of choice shuffling.")
    args, _ = parser.parse_known_args()

    train_df = pd.read_json(args.train_data_file_location, lines=True)
    df = pd.read_json(args.test_data_file_location, lines=True)

    similar_training_questions = pd.read_csv(args.similar_questions_file_location)
    router_df = pd.read_csv(args.router_preferences_file_location)

    gpt_cot_df = pd.read_csv(args.gpt_cot_file_location)
    llama_cot_df = pd.read_csv(args.llama_cot_file_location)

    openai_client = OpenAI()
    fireworks_client = Fireworks()

    predicted_answers = []
    actual_answers = []
    index_values = []

    max_workers = 6
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_row = dict()
        for i_, row in df.iterrows():
            similar_train_rows = similar_training_questions[similar_training_questions['test_idx'] == row.name]
            router_preference = router_df.iloc[row.name]
            model_id = router_preference['model']
            use_cot = router_preference['use_cot']

            examples = create_examples(
                similar_train_rows['train_idx'].tolist(),
                train_df,
                gpt_cot_df,
                llama_cot_df,
                max_examples=args.num_examples
            )

            client = openai_client if 'gpt' in model_id else fireworks_client

            future = executor.submit(
                answer_via_ensemble,
                client,
                model_id,
                row['question'],
                row['options'],
                examples,
                args.temp,
                num_models=args.num_shuffles,
                cot=use_cot
            )
            future_to_row[future] = row

        for future in tqdm(as_completed(future_to_row), total=len(df)):
            row = future_to_row[future]
            try:
                votes_by_answer_idx = future.result()
                num_votes = sum(votes_by_answer_idx.values())
                if num_votes < args.num_shuffles:
                    print(f'Row {row.name} only has {num_votes} votes')
                    continue

                predicted_answer = max(votes_by_answer_idx, key=votes_by_answer_idx.get)
                predicted_answers.append(predicted_answer)
                actual_answers.append(row['answer_idx'])
                index_values.append(row.name)
            except Exception as exc:
                print(f'Row {row.name} generated an exception: {exc}')

    print("Evaluation complete.")

    num_correct = sum([predicted_answers[i] == actual_answers[i] for i in range(len(predicted_answers))])
    pct_correct = num_correct / len(predicted_answers)
    print(f'Pct Correct,{pct_correct}')
    print(f'Num Correct,{num_correct}')
    print(f'Total,{len(predicted_answers)}')
